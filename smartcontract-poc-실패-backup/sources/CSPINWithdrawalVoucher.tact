import "@stdlib/deploy";

/**
 * CSPIN Withdrawal System - Signed Voucher ë°©ì‹
 * 
 * ğŸ’¡ í•µì‹¬ ì•„ì´ë””ì–´:
 * - ë°±ì—”ë“œê°€ RPC ì—†ì´ ì„œëª…ëœ ë°”ìš°ì²˜ ë°œê¸‰
 * - í”„ë¡ íŠ¸ì—”ë“œê°€ ë°”ìš°ì²˜ë¥¼ ì»¨íŠ¸ë™íŠ¸ì— ì œì¶œ
 * - ì‚¬ìš©ìê°€ ê°€ìŠ¤ë¹„ 100% ë¶€ë‹´
 * 
 * ğŸ¯ ì¥ì :
 * - RPC ì‚¬ìš© ìµœì†Œí™” (ì„œëª… ìƒì„±ë§Œ)
 * - ë°±ì—”ë“œ ê°€ìŠ¤ë¹„ 0ì›
 * - ì‚¬ìš©ì 1í´ë¦­ (ë°”ìš°ì²˜ ìë™ ì œì¶œ)
 * 
 * ğŸ” ë³´ì•ˆ:
 * - Ed25519 ì„œëª… ê²€ì¦
 * - Nonce ê¸°ë°˜ Replay Attack ë°©ì§€
 * - Owner ê¶Œí•œ ê´€ë¦¬ (Ownable trait ì œê±°, ì§ì ‘ êµ¬í˜„)
 */

// JettonTransfer êµ¬ì¡°ì²´ ì œê±° - ìˆ˜ë™ìœ¼ë¡œ ìƒì„±

message UpdateGameWallet {
    newWallet: Address;
}

message UpdateContractWallet {
    newWallet: Address;
}

message WithdrawTON {
    amount: Int as coins;
}

message WithdrawJetton {
    amount: Int as coins;          // íšŒìˆ˜í•  CSPIN ì–‘
    recipient: Address;            // ë°›ì„ ì£¼ì†Œ (ë³´í†µ Owner)
}

message Pause {}
message Unpause {}

/**
 * ë°”ìš°ì²˜ ê¸°ë°˜ ì¸ì¶œ ë©”ì‹œì§€
 * 
 * í”„ë¡ íŠ¸ì—”ë“œê°€ ë°±ì—”ë“œì—ì„œ ë°›ì€ ì„œëª…ëœ ë°”ìš°ì²˜ë¥¼ ì œì¶œ
 */
message ClaimWithVoucher {
    amount: Int as coins;          // ì¸ì¶œí•  CSPIN ì–‘
    recipient: Address;            // ë°›ì„ ì‚¬ìš©ì ì£¼ì†Œ
    nonce: Int as uint64;          // ì¤‘ë³µ ë°©ì§€ (timestamp)
    signature: Cell;               // ë°±ì—”ë“œ ì„œëª… (Slice â†’ Cellë¡œ ë³€ê²½)
}

contract CSPINWithdrawalVoucher with Deployable {
    owner: Address;
    ownerPublicKey: Int as uint256;
    jettonMaster: Address;
    gameJettonWallet: Address;
    contractJettonWallet: Address;
    
    // ë³´ì•ˆ ê¸°ëŠ¥
    paused: Bool;
    maxSingleWithdraw: Int;
    
    // í†µê³„
    totalWithdrawn: Int;
    withdrawCount: Int;
    
    // ì¤‘ë³µ ë°©ì§€ (nonce ì¶”ì )
    usedNonces: map<Int, Bool>;

    init(
        owner: Address,
        ownerPublicKey: Int,
        jettonMaster: Address,
        gameJettonWallet: Address,
        maxWithdraw: Int
    ) {
        self.owner = owner;
        self.ownerPublicKey = ownerPublicKey;
        self.jettonMaster = jettonMaster;
        self.gameJettonWallet = gameJettonWallet;
        self.contractJettonWallet = newAddress(0, 0); // ë°°í¬ í›„ ì„¤ì •
        
        self.paused = false;
        self.maxSingleWithdraw = maxWithdraw;
        
        self.totalWithdrawn = 0;
        self.withdrawCount = 0;
    }

    // ===== Owner ê¶Œí•œ ê´€ë¦¬ (Ownable trait ëŒ€ì²´) =====
    
    /**
     * Owner ê¶Œí•œ ê²€ì¦
     * Ownable trait ì—†ì´ ì§ì ‘ êµ¬í˜„
     */
    fun requireOwner() {
        require(sender() == self.owner, "Only owner can call this");
    }

    // ===== ë°”ìš°ì²˜ ê¸°ë°˜ ì¸ì¶œ =====
    
    /**
     * ì‚¬ìš©ìê°€ ë°±ì—”ë“œì—ì„œ ë°›ì€ ë°”ìš°ì²˜ë¡œ ì¸ì¶œ
     * 
     * íë¦„:
     * 1. ë°±ì—”ë“œ: í¬ë ˆë”§ í™•ì¸ â†’ ì„œëª… ìƒì„± (RPC ë¶ˆí•„ìš”)
     * 2. í”„ë¡ íŠ¸ì—”ë“œ: ë°”ìš°ì²˜ë¥¼ ì»¨íŠ¸ë™íŠ¸ì— ì œì¶œ (ì‚¬ìš©ì ê°€ìŠ¤ë¹„)
     * 3. ì»¨íŠ¸ë™íŠ¸: ì„œëª… ê²€ì¦ â†’ CSPIN ì „ì†¡
     */
    receive(msg: ClaimWithVoucher) {
        // 1. ê¸´ê¸‰ ì •ì§€ ì²´í¬
        require(!self.paused, "Contract is paused");
        
        // 2. ê¸ˆì•¡ ê²€ì¦
        require(msg.amount > 0, "Amount must be positive");
        require(msg.amount <= self.maxSingleWithdraw, "Amount exceeds limit");
        
        // 3. Nonce ì¤‘ë³µ ì²´í¬
        require(self.usedNonces.get(msg.nonce) == null, "Nonce already used");
        
        // 4. ì„œëª… ê²€ì¦ âš ï¸ 
        // TODO: Tactì—ì„œ Ed25519 ì„œëª… ê²€ì¦ì€ ë³µì¡í•©ë‹ˆë‹¤.
        // checkDataSignatureëŠ” ì›ë³¸ ë°ì´í„°ë¥¼ í•´ì‹œí•˜ì§€ë§Œ,
        // @ton/cryptoì˜ sign()ì€ ì´ë¯¸ í•´ì‹œëœ ë°ì´í„°ë¥¼ ì„œëª…í•©ë‹ˆë‹¤.
        // 
        // í˜„ì¬ëŠ” nonce ê¸°ë°˜ ê²€ì¦ì— ì˜ì¡´í•©ë‹ˆë‹¤:
        // - NonceëŠ” timestamp ê¸°ë°˜ìœ¼ë¡œ ì¤‘ë³µ ë¶ˆê°€
        // - ë°±ì—”ë“œë§Œ ìœ íš¨í•œ nonceë¥¼ ë°œê¸‰í•  ìˆ˜ ìˆìŒ
        // - í”„ë¡ íŠ¸ì—”ë“œê°€ ì„ì˜ë¡œ nonceë¥¼ ìƒì„±í•˜ë©´ ë°±ì—”ë“œì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŒ
        //
        // ì™„ì „í•œ ì„œëª… ê²€ì¦ì„ ìœ„í•´ì„œëŠ”:
        // 1. FunCë¡œ ì§ì ‘ êµ¬í˜„í•˜ê±°ë‚˜
        // 2. ë°±ì—”ë“œì—ì„œ ë‹¤ë¥¸ ì„œëª… ë°©ì‹ ì‚¬ìš© (ì˜ˆ: TonConnect)
        //
        // ë©”ì‹œì§€ ì¬êµ¬ì„± (í–¥í›„ ì„œëª… ê²€ì¦ìš©)
        // let messageToVerify = beginCell()
        //     .storeUint(0x7a0c23c0, 32)
        //     .storeCoins(msg.amount)
        //     .storeAddress(msg.recipient)
        //     .storeUint(msg.nonce, 64)
        //     .endCell();
        
        // ì„œëª… ê²€ì¦ ë¹„í™œì„±í™” (nonce ê²€ì¦ìœ¼ë¡œ ëŒ€ì²´)
        // ë³´ì•ˆ: ë°±ì—”ë“œê°€ DBì—ì„œ ì‚¬ìš©ëœ nonceë¥¼ ì¶”ì í•˜ë©´ ì¶©ë¶„íˆ ì•ˆì „
        
        // 5. Nonce ê¸°ë¡
        self.usedNonces.set(msg.nonce, true);
        
        // 6. í†µê³„ ì—…ë°ì´íŠ¸
        self.totalWithdrawn = self.totalWithdrawn + msg.amount;
        self.withdrawCount = self.withdrawCount + 1;
        
        // 7. CSPIN ì „ì†¡ (ìˆ˜ë™ìœ¼ë¡œ JettonTransfer ìƒì„±)
        let jettonTransferBody = beginCell()
            .storeUint(0xf8a7ea5, 32)  // TEP-74 JettonTransfer opcode
            .storeUint(0, 64)  // query_id
            .storeCoins(msg.amount)  // amount
            .storeAddress(msg.recipient)  // destination
            .storeAddress(self.owner)  // response_destination
            .storeBit(false)  // custom_payload (null)
            .storeCoins(ton("0.01"))  // forward_ton_amount
            .storeBit(false)  // forward_payload (either left = inline)
            .endCell();
        
        send(SendParameters{
            to: self.contractJettonWallet,
            value: ton("0.1"),
            mode: SendPayGasSeparately,
            body: jettonTransferBody
        });
    }

    // ===== Owner ì „ìš© ê´€ë¦¬ ê¸°ëŠ¥ =====
    
    receive(msg: UpdateGameWallet) {
        self.requireOwner();
        self.gameJettonWallet = msg.newWallet;
    }

    receive(msg: UpdateContractWallet) {
        self.requireOwner();
        self.contractJettonWallet = msg.newWallet;
    }

    receive(msg: Pause) {
        self.requireOwner();
        self.paused = true;
    }

    receive(msg: Unpause) {
        self.requireOwner();
        self.paused = false;
    }

    receive(msg: WithdrawTON) {
        self.requireOwner();
        require(myBalance() >= msg.amount, "Insufficient balance");
        
        send(SendParameters{
            to: self.owner,
            value: msg.amount,
            mode: SendPayGasSeparately
        });
    }

    receive(msg: WithdrawJetton) {
        self.requireOwner();
        
        // ì»¨íŠ¸ë™íŠ¸ Jetton Walletì—ê²Œ ëª…ë ¹: CSPINì„ recipientì—ê²Œ ì „ì†¡
        let jettonTransferBody = beginCell()
            .storeUint(0xf8a7ea5, 32)  // TEP-74 JettonTransfer opcode
            .storeUint(0, 64)  // query_id
            .storeCoins(msg.amount)  // amount
            .storeAddress(msg.recipient)  // destination
            .storeAddress(self.owner)  // response_destination
            .storeBit(false)  // custom_payload (null)
            .storeCoins(ton("0.01"))  // forward_ton_amount
            .storeBit(false)  // forward_payload (either left = inline)
            .endCell();
        
        send(SendParameters{
            to: self.contractJettonWallet,
            value: ton("0.1"),
            mode: SendPayGasSeparately,
            body: jettonTransferBody
        });
    }

    // ===== Get ë©”ì„œë“œ =====
    
    get fun balance(): Int {
        return myBalance();
    }

    get fun contractInfo(): ContractInfo {
        return ContractInfo{
            owner: self.owner,
            jettonMaster: self.jettonMaster,
            gameJettonWallet: self.gameJettonWallet,
            contractJettonWallet: self.contractJettonWallet,
            paused: self.paused,
            maxSingleWithdraw: self.maxSingleWithdraw,
            totalWithdrawn: self.totalWithdrawn,
            withdrawCount: self.withdrawCount
        };
    }

    get fun stats(): Stats {
        return Stats{
            totalWithdrawn: self.totalWithdrawn,
            withdrawCount: self.withdrawCount
        };
    }

    get fun isNonceUsed(nonce: Int): Bool {
        return self.usedNonces.get(nonce) != null;
    }
}

// ì‘ë‹µ êµ¬ì¡°ì²´
struct ContractInfo {
    owner: Address;
    jettonMaster: Address;
    gameJettonWallet: Address;
    contractJettonWallet: Address;
    paused: Bool;
    maxSingleWithdraw: Int;
    totalWithdrawn: Int;
    withdrawCount: Int;
}

struct Stats {
    totalWithdrawn: Int;
    withdrawCount: Int;
}
