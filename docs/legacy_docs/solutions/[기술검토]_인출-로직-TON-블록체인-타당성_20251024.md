# [기술검토] 인출 로직 - TON 블록체인 타당성 분석

**작성일:** 2025-10-24  
**상태:** 🔴 **Critical Issues Found** - 2가지 근본적 문제 발견  
**버전:** CandleSpinner v2.5.0

---

## 📋 Executive Summary

현재 CSPIN 인출 로직은 **기술적으로 불가능한 구조**를 가지고 있습니다.

| 항목 | 현재 구현 | 문제 | 타당성 |
|------|---------|------|--------|
| **게임 지갑 (Server-side)** | ✅ 존재 | 서버가 개인키 소유 | ❌ **앞뒤가 맞지 않음** |
| **사용자 지갑 (Client-side)** | ❌ 없음 | 인출 받을 주소만 제시 | ❌ **서명 불가능** |
| **Jetton 송금** | ✅ 기술적 가능 | TON 표준 준수 | ✅ 가능 |
| **seqno 원자성** | ✅ 구현됨 | KV 사용 | ⚠️ 불완전 |
| **보안** | ❌ 위험 | 서버가 모든 개인키 소유 | 🔴 **심각** |

---

## 🔴 **문제 1: 아키텍처 모순 - 누가 거래에 서명하는가?**

### 현재 흐름 분석

```
사용자 → API 요청: "/api/initiate-withdrawal"
       {
         walletAddress: "UQA...",           // 사용자 지갑 (정보만)
         withdrawalAmount: 100               // 100 CSPIN
       }
         ↓
   서버 (Cloudflare Worker)
     1. 게임 지갑 생성 (개인키 사용)
     2. 거래 생성: "게임 지갑" → "사용자 지갑" CSPIN 송금
     3. 서버가 개인키로 서명
     4. BOC 생성 및 TonAPI로 전송
         ↓
   TON 블록체인
     • 거래 실행: 게임 지갑 CSPIN 차감
     • 사용자 지갑 CSPIN 증가
```

### 🔴 핵심 문제: "신뢰 관계" 위반

| 구분 | 현재 구현 | 문제점 |
|------|---------|--------|
| **거래 서명자** | 서버 (게임 지갑 개인키 사용) | ✅ 기술적으로 가능 |
| **거래 수혜자** | 사용자 지갑 | ❌ **사용자 승인 없음** |
| **사용자 역할** | 수동적 (정보만 제시) | 🔴 **거래에 참여 불가** |
| **신뢰 모델** | **중앙 집중식 (게임 운영자 신뢰)** | ❌ **블록체인 철학 위배** |

---

### 🤔 "이게 왜 문제인가?"

#### 시나리오 1: 정상 작동 시
```
1. 사용자: "100 CSPIN 인출해줘"
2. 서버: "OK, 내 게임 지갑에서 당신 지갑으로 100 CSPIN 보낼게"
3. 서버: 게임 지갑 개인키로 거래 서명 ✅
4. 결과: 블록체인에 기록됨 ✅
```

#### ❌ 시나리오 2: 서버가 악의적으로 행동 시
```
1. 사용자: "100 CSPIN 인출해줘"
2. 서버: (악의적) 1,000,000 CSPIN을 자신 지갑으로 송금 거래 생성
3. 서버: 게임 지갑 개인키로 서명 (서버가 개인키 소유)
4. 결과: 사용자는 막을 수 없음 ❌
```

#### ⚠️ 시나리오 3: 서버 해킹 시
```
1. 해커: 게임 지갑 개인키 탈취
2. 해커: 게임 지갑 전체 CSPIN을 자신 주소로 송금
3. 모든 사용자: 손실 🔴
```

---

## 🔴 **문제 2: TonConnect 부재 - 사용자 서명 불가**

### 현재 구조

```typescript
// 현재 코드: initiate-withdrawal.ts (라인 293-299)
const transfer = gameWallet.createTransfer({
  seqno,
  secretKey: keyPair.secretKey,        // ← 서버 개인키
  messages: [transferMessage],
  sendMode: SendMode.PAY_GAS_SEPARATELY | SendMode.IGNORE_ERRORS
});
```

**문제:**
- ❌ 사용자 지갑의 개인키 없음
- ❌ 사용자가 거래에 서명할 수 없음
- ❌ TonConnect 미사용 (Telegram Mini App 표준)
- ❌ 사용자는 거래 사실을 모를 수도 있음

### 정상적인 구조 (TonConnect 기반)

```typescript
// 올바른 구현 (사용자 서명)
const transfer = userWallet.createTransfer({
  seqno: userSeqno,                    // ← 사용자 지갑 seqno
  secretKey: userPrivateKey,           // ← 사용자 개인키 (클라이언트에서 서명)
  messages: [paymentMessage],          // ← 게임 서버로 결제 메시지
  sendMode: SendMode.PAY_GAS_SEPARATELY
});
// 사용자가 TonConnect로 서명 ✅
```

---

## ⚖️ **근본적인 설계 선택: 2가지 아키텍처**

### 옵션 A: "중앙 집중식" (현재 구현) ❌

```
사용자                  게임 서버              TON 블록체인
  │                      │                      │
  ├─ 인출 요청 ─────────>│                      │
  │                      ├─ 게임 지갑 서명 ────>│
  │                      │    (개인키 사용)    │
  │                      │                 ✅ 기록
  │  CSPIN 받음  <───── │ <───────────────────│
  │                                           
```

**장점:**
- ✅ 서버에서 모든 제어 가능
- ✅ 신속한 처리

**단점:**
- ❌ **사용자 신뢰 필요** (서버가 악의적이면 모두 손실)
- ❌ 모든 개인키를 서버가 관리 (해킹 위험)
- ❌ TonConnect/웹3 원칙 위배
- ❌ 규제 (중앙화) 위험
- 🔴 **현재 문제: 실패율 높음 (이유: 아래 참조)**

---

### 옵션 B: "분산식" (TonConnect 기반) ✅

```
사용자 클라이언트        TonConnect             게임 서버              TON 블록체인
  │                      │                      │                      │
  ├─ 인출 요청 ─────────────────────────────>│                      │
  │                                           │                      │
  │  TonConnect 팝업 ← ─── ─ ─ ─ ─ ─ ─ ─ ─ ─│                      │
  │  (사용자 확인)                           │                      │
  │       │                                   │                      │
  │  서명 요청 ────────>│                      │                      │
  │                      ├─ 게임 서버 결제 ──>│                      │
  │  사용자 지갑 서명 ──>│                      ├─ Jetton 송금 ──────>│
  │                      │                      │                  ✅ 기록
  │  ✅ 거래 완료  <─ ─ ─│ ─ ─ ─ ─ ─ ─ ─ ─ ─│ ←─────────────────│
  │
```

**장점:**
- ✅ 사용자가 직접 서명 (신뢰 불필요)
- ✅ 사용자만 자신의 개인키 소유
- ✅ TonConnect 표준 준수 (Telegram Mini App)
- ✅ 분산 신뢰 모델
- ✅ 규제 준수

**단점:**
- ⚠️ 구현 복잡도 높음
- ⚠️ 사용자 액션 필요 (서명 확인)

---

## 🔴 **왜 현재 인출이 실패하는가?**

현재 "중앙 집중식" 아키텍처에서 실패하는 이유들:

### 1️⃣ **RPC 엔드포인트 문제**

```typescript
// 라인 207-210: ANKR_JSON_RPC_HTTPS_ENDPOINT
const ankrJsonRpcUrl = env.ANKR_JSON_RPC_HTTPS_ENDPOINT;
if (!ankrJsonRpcUrl) {
  throw new Error('ANKR_JSON_RPC_HTTPS_ENDPOINT 환경변수 미설정');
}
```

**현재 상태:**
```
sendBocViaTonAPI() 사용 (라인 304)
  ↓
https://tonapi.io/v1/blockchain/message
  ↓
이것은 JSON-RPC가 아님 ❌
```

**개선 필요:**
```typescript
// ANKR JSON-RPC 직접 사용
const sendTxViaAnkr = async (boc: string) => {
  const response = await fetch(ankrJsonRpcUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'sendBoc',
      params: [boc],
      id: 1
    })
  });
  // ...
};
```

### 2️⃣ **Jetton 지갑 주소 오류**

```typescript
// 라인 132-148: TonAPI 사용
const getJettonWalletAddress = async (...) => {
  const url = 'https://tonapi.io/v2/jettons/wallets';
  // ... 이것도 JSON-RPC가 아님
};
```

**문제점:**
- ✅ Jetton 지갑 주소를 정확히 조회했는가?
- ✅ 주소 형식이 올바른가?
- 🔴 실패할 경우 전체 거래 실패

### 3️⃣ **seqno 동기화 문제**

```typescript
// 라인 52-70: KV 기반 seqno
async function getAndIncrementSeqno(env: any): Promise<number> {
  const SEQNO_KEY = 'game_wallet_seqno';
  // ...
  await env.CREDIT_KV.put(SEQNO_KEY, nextSeqno.toString());
}
```

**문제점:**
- ⚠️ 실제 블록체인 seqno ≠ KV seqno
- ⚠️ 거래 충돌 가능성
- 🔴 동시 다중 인출 시 실패

### 4️⃣ **게임 지갑 TON 부족**

```typescript
// 라인 160-180: 잔액 확인
const tonStatus = await getGameWalletTonBalance(gameWallet.address.toString());
if (!tonStatus.isEnough) {
  console.warn(`⚠️ 게임 지갑의 TON 부족: ...`);
  // 경고만 하고 진행 ← 🔴 위험
}
```

**문제점:**
- 🔴 게임 지갑에 TON이 없으면 거래 불가능
- ⚠️ 수수료 미지불로 인한 실패

### 5️⃣ **권한 검증 부재**

```typescript
// 라인 200-245: 사용자 크레딧 확인
const userState: UserState = stateData ? JSON.parse(stateData) : { ... };
if (userState.credit < withdrawalAmount) {
  return new Response(...);
}
```

**문제점:**
- ❌ 사용자가 거래를 승인했는가?
- ❌ 이중 지출 방지가 없음
- ❌ TonConnect 검증 없음

---

## ✅ **해결책: 3단계 전환**

### **Phase 1: 중앙화 → 반중앙화 (단기, 즉시)**

**현재 문제 해결:**

```typescript
// 1. Ankr JSON-RPC 직접 사용으로 전환
const sendTxViaAnkr = async (boc: string) => {
  const response = await fetch(env.ANKR_JSON_RPC_HTTPS_ENDPOINT, {
    method: 'POST',
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'sendBoc',
      params: [boc],
      id: 1
    })
  });
  const data = await response.json();
  return data.result || data.params?.result;
};

// 2. 블록체인에서 실제 seqno 조회
const getActualSeqno = async (address: string) => {
  const response = await fetch(env.ANKR_JSON_RPC_HTTPS_ENDPOINT, {
    method: 'POST',
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'getAccountState',
      params: [address],
      id: 1
    })
  });
  const data = await response.json();
  return data.result?.state?.account?.storage?.state?.seq_no || 0;
};

// 3. TON 잔액 필수 확인
const tonStatus = await getGameWalletTonBalance(...);
if (!tonStatus.isEnough) {
  throw new Error('게임 지갑의 TON 부족');  // 즉시 실패
}
```

---

### **Phase 2: TonConnect 통합 (중기, 1-2주)**

**사용자 서명 추가:**

```typescript
// 클라이언트 (React)
import { TonConnectUI } from '@tonconnect/ui';

const tonConnect = new TonConnectUI({
  manifestUrl: 'https://aiandyou.me/tonconnect-manifest.json'
});

const initiateWithdrawal = async () => {
  // 사용자가 TonConnect로 연결된 상태
  const userWallet = tonConnect.wallet?.account;
  
  // 게임 서버에 인출 요청
  const response = await fetch('/api/initiate-withdrawal', {
    method: 'POST',
    body: JSON.stringify({
      walletAddress: userWallet.address,
      withdrawalAmount: 100,
      userPublicKey: userWallet.publicKey  // ← 새 필드
    })
  });
  
  // 서버가 거래 생성 후 반환
  const { transaction } = await response.json();
  
  // 사용자가 TonConnect로 서명
  const signed = await tonConnect.sendTransaction(transaction);
};
```

---

### **Phase 3: 완전 분산화 (장기, 2-3주)**

**L2 결제 채널 구현:**

```typescript
// 게임 <-> 사용자 간 결제 채널
// 빠른 인출, 블록체인 정산은 필요할 때만
```

---

## 📊 **현재 코드 평가표**

| 기술 | 구현 상태 | 평가 | 개선 필요 |
|------|---------|------|---------|
| **Jetton Transfer** | ✅ | TEP-74 준수 | 주소 검증 강화 |
| **seqno 관리** | ⚠️ | KV 기반 (불완전) | 블록체인 seqno 동기화 |
| **RPC 통신** | ❌ | TonAPI만 사용 | Ankr JSON-RPC 통합 |
| **개인키 관리** | ❌ | 중앙화 | TonConnect로 전환 |
| **권한 검증** | ❌ | 없음 | TonConnect + 서명 검증 |
| **에러 처리** | ⚠️ | 기본적 | 상세 진단 추가 필요 |
| **보안** | 🔴 | 위험 (서버 신뢰 필요) | 분산 신뢰 모델로 전환 |

---

## 🎯 **즉시 액션 아이템**

### 우선순위 1: RPC 통합 (2시간) 🔴
```
[ ] 1. Ankr JSON-RPC 직접 연결 코드 작성
[ ] 2. sendBocViaTonAPI() → sendBocViaAnkr() 변경
[ ] 3. 테스트 (debug API 사용)
```

### 우선순위 2: seqno 동기화 (1시간) 🟠
```
[ ] 1. 블록체인에서 실제 seqno 조회
[ ] 2. KV와 블록체인 seqno 비교
[ ] 3. 불일치 시 처리 로직
```

### 우선순위 3: TON 잔액 필수 확인 (30분) 🟡
```
[ ] 1. 게임 지갑 TON 잔액 확인 강제
[ ] 2. 부족 시 즉시 실패 (경고 아님)
[ ] 3. 알림 추가
```

### 우선순위 4: TonConnect 전환 (1-2주) 🔵
```
[ ] 1. TonConnect UI 통합
[ ] 2. 사용자 서명 플로우 구현
[ ] 3. 클라이언트 거래 서명
```

---

## 📌 **결론**

**현재 코드는 기술적으로 가능하지만, 실전 운영에는 부족합니다.**

### 현재 상태
- ✅ 기본 로직: 정상
- ❌ RPC 연결: 미완성
- ❌ seqno 동기화: 불완전
- ❌ 보안: 위험 (중앙화)
- 🔴 **실패율: 높음 (RPC 관련)**

### 해결 우선순위
1. **즉시:** RPC 통합 (Ankr JSON-RPC)
2. **단기:** seqno 블록체인 동기화
3. **중기:** TonConnect 통합 (사용자 서명)
4. **장기:** L2 결제 채널 (고속 인출)

---

## 📚 **참고**

- **TON Wallet Spec:** https://docs.ton.org/develop/smart-contracts/tutorials/wallet-v5
- **Jetton Standard (TEP-74):** https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md
- **TonConnect:** https://docs.ton.org/develop/dapps/ton-connect/
- **Ankr RPC:** https://www.ankr.com/rpc/
