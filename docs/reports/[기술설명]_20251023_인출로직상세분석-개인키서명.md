# 🔐 인출(Withdrawal) 로직 상세 설명

**작성일:** 2025-10-23  
**대상:** 게임 지갑→사용자 지갑 CSPIN 전송 메커니즘  
**버전:** v1.0

---

## 📌 **핵심 요약**

> **사용자는 승인을 누르지 않습니다!**  
> 게임 서버(Cloudflare Worker)가 **게임 지갑의 개인키를 보유**하고 있어서,  
> 사용자를 대신하여 **트랜잭션을 자동 서명 후 전송**합니다.

---

## 🎯 **인출 플로우 (10단계)**

```
사용자가 "인출" 버튼 클릭
    ↓
[Step 1] 요청 파싱
    └─ walletAddress, withdrawalAmount 추출
    ↓
[Step 2] KV에서 사용자 크레딧 확인
    └─ 인출액 <= 크레딧? 검증
    ↓
[Step 3-4] 게임 지갑 복원
    ├─ env.GAME_WALLET_PRIVATE_KEY 읽기
    ├─ 개인키 → 키페어 생성
    └─ 게임 지갑 주소 생성
    ↓
[Step 5] seqno 증가
    └─ 트랜잭션 순서 번호 (중복 방지)
    ↓
[Step 6] 게임 Jetton 지갑 조회
    ├─ TonAPI 호출
    └─ 게임 지갑이 CSPIN을 보관하는 Jetton 지갑 주소 조회
    ↓
[Step 7-8] 트랜잭션 메시지 생성
    ├─ Jetton Transfer Payload 생성 (TEP-74 표준)
    ├─ 목표: 게임 Jetton 지갑
    ├─ 명령: 사용자에게 CSPIN 전송
    ├─ 금액: withdrawalAmount
    └─ 수신자: walletAddress
    ↓
[Step 9] 트랜잭션 서명
    ├─ 게임 지갑의 개인키 사용
    └─ 트랜잭션에 디지털 서명
    ↓
[Step 10] BOC 생성 및 TonAPI로 전송
    ├─ Binary Object Code (BOC) 생성
    ├─ TonAPI에 POST /blockchain/message
    └─ TON 블록체인에 브로드캐스트
    ↓
[Step 11] KV 업데이트
    ├─ 사용자 크레딧 차감
    └─ 트랜잭션 로그 저장
    ↓
✅ 사용자 지갑에 CSPIN 도착!
```

---

## 🔑 **핵심 차이: 중앙화 vs 분산화**

### **일반적인 Web3 앱 (사용자가 승인)**

```
사용자 지갑 (MetaMask 등)
    ↓
사용자가 "승인" 클릭 ← 서명 팝업 나타남!
    ↓
트랜잭션 서명됨
    ↓
블록체인에 브로드캐스트
```

**특징:**
- ✅ 사용자가 직접 서명 (신뢰성 높음)
- ❌ 사용자 확인 필요 (UX 나쁨)
- ❌ 대량 트랜잭션 불가능

---

### **CandleSpinner 인출 로직 (게임 서버가 서명)**

```
게임 서버가 개인키 보관
    ↓
사용자가 "인출" 클릭 (확인 X)
    ↓
서버가 사용자 대신 트랜잭션 생성
    ↓
서버의 개인키로 서명
    ↓
서버가 TonAPI로 전송
```

**특징:**
- ✅ 사용자 확인 불필요 (UX 좋음)
- ✅ 즉시 처리 가능 (빠름)
- ⚠️ 중앙화 (게임 서버를 신뢰해야 함)

---

## 🏗️ **아키텍처 다이어그램**

```
┌─────────────────────────────────────────────────────────────┐
│                   사용자 (Browser)                          │
│  "인출 100 CSPIN" 버튼 클릭                                │
└────────────────────┬────────────────────────────────────────┘
                     │ POST /api/initiate-withdrawal
                     │ { walletAddress, withdrawalAmount }
                     ↓
┌─────────────────────────────────────────────────────────────┐
│         Cloudflare Worker (게임 서버)                       │
│  ┌────────────────────────────────────────────────────────┐│
│  │ Step 1-5: 입력 검증, 게임 지갑 복원, seqno 증가      ││
│  └────────────────────────────────────────────────────────┘│
│  ┌────────────────────────────────────────────────────────┐│
│  │ Step 6: TonAPI 호출                                   ││
│  │   GET /v2/jettons/wallets                             ││
│  │   ?owner_account=<game_wallet>                        ││
│  │   &jetton=<CSPIN_master>                              ││
│  │   ↓ 응답: gameJettonWalletAddress                     ││
│  └────────────────────────────────────────────────────────┘│
│  ┌────────────────────────────────────────────────────────┐│
│  │ Step 7-8: Jetton Transfer Payload 생성                ││
│  │   ├─ Op: 0xf8a7ea5 (Jetton transfer)                  ││
│  │   ├─ Amount: 100 CSPIN                                ││
│  │   ├─ Destination: <user_wallet>                       ││
│  │   └─ ResponseTo: <game_wallet>                        ││
│  └────────────────────────────────────────────────────────┘│
│  ┌────────────────────────────────────────────────────────┐│
│  │ Step 9: 트랜잭션 서명                                 ││
│  │   ├─ 개인키 사용: env.GAME_WALLET_PRIVATE_KEY ← 중요! ││
│  │   ├─ 서명자: 게임 지갑                                ││
│  │   └─ seqno 포함: 트랜잭션 순서 번호                   ││
│  └────────────────────────────────────────────────────────┘│
│  ┌────────────────────────────────────────────────────────┐│
│  │ Step 10: BOC 생성 및 TonAPI 전송                      ││
│  │   POST https://tonapi.io/v1/blockchain/message        ││
│  │   { "boc": "<base64_encoded_transaction>" }           ││
│  │   ↓ 응답: txHash                                      ││
│  └────────────────────────────────────────────────────────┘│
│  ┌────────────────────────────────────────────────────────┐│
│  │ Step 11: KV 업데이트                                  ││
│  │   ├─ 크레딧 차감: 100 CSPIN                            ││
│  │   └─ 트랜잭션 로그 저장                                ││
│  └────────────────────────────────────────────────────────┘│
└────────────────────┬────────────────────────────────────────┘
                     │ POST 응답
                     │ { success: true, txHash: "..." }
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                 TON 블록체인                                │
│  트랜잭션 검증 및 실행                                     │
│  게임 Jetton 지갑 → 사용자 지갑 (100 CSPIN)              │
└─────────────────────────────────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                   사용자 지갑                               │
│  +100 CSPIN 도착! ✅                                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔐 **개인키 관리 - 매우 중요!**

### **개인키 저장 위치**

```typescript
// env.GAME_WALLET_PRIVATE_KEY는 어디에?
// → Cloudflare 환경 변수 (wrangler.toml)

[env.production.vars]
GAME_WALLET_PRIVATE_KEY = "0x..." ← 매우 민감한 정보!
```

### **위험성**

```
❌ 개인키 유출 = 게임 지갑의 모든 토큰 탈취!
   - 누구든 이 개인키로 트랜잭션 서명 가능
   - 게임 지갑의 모든 CSPIN이 위험
   
✅ 따라서 Cloudflare의 보안 시스템에 의존:
   - 환경 변수 암호화
   - 접근 제어
   - 감사 로그
```

### **실제 구현**

```typescript
// Step 4: 개인키에서 키페어 생성
const keyPair = keyPairFromSecretKey(
  Buffer.from(gameWalletPrivateKey, 'hex')
);

// Step 9: 키페어로 트랜잭션 서명
const transfer = gameWallet.createTransfer({
  seqno,
  secretKey: keyPair.secretKey,  ← 개인키 사용!
  messages: [transferMessage]
});

// ⚠️ 이 순간, 게임 서버가 사용자 대신 서명!
```

---

## 📊 **트랜잭션 구조 (TEP-74 Jetton 표준)**

### **Jetton Transfer Payload**

```
┌────────────────────────────────────┐
│  Opcode: 0xf8a7ea5                │ ← Jetton transfer 명령
│  query_id: 0                       │
│  amount: 100000000000 (100 CSPIN)  │
│  destination: <user_wallet>        │ ← 받는 사람
│  response_destination: <game_wallet>│ ← 응답 받을 주소
│  custom_payload: 0                 │ ← 추가 데이터 없음
│  forward_ton_amount: 1             │ ← 1 nanoton (수수료)
│  forward_payload: 0                │ ← 추가 메시지 없음
└────────────────────────────────────┘
```

### **이 Payload를 담는 Message**

```
┌────────────────────────────────────┐
│ To: <game_jetton_wallet>           │ ← Jetton 지갑에 메시지
│ Value: 0.03 TON                    │ ← 수수료
│ Body: <위의 Payload>               │ ← Jetton 전송 지시
└────────────────────────────────────┘
```

### **이 Message를 담는 Transaction**

```
┌────────────────────────────────────┐
│ From: <game_wallet>                │ ← 발신자
│ Seqno: 123                         │ ← 순서 번호
│ Messages: [위의 Message]           │ ← 전송할 메시지
│ Signature: <개인키 서명>            │ ← 게임 서버의 서명
└────────────────────────────────────┘
```

---

## 🔄 **왜 "사용자 승인"이 필요 없나?**

### **이유 1: 게임 지갑이 서명자**

```
일반적인 경우:
  사용자 지갑 (개인키) → 사용자가 승인해야 함

CandleSpinner:
  게임 지갑 (개인키) → 게임 서버가 자동 서명
  
사용자의 지갑은 '수신자' 역할만 함 (승인 필요 X)
```

### **이유 2: 트랜잭션 흐름**

```
Step 1: 게임 서버가 트랜잭션 생성
Step 2: 게임 서버가 개인키로 서명
Step 3: 게임 서버가 블록체인으로 전송
Step 4: 블록체인이 검증 (서명이 게임 지갑 것인가?)
Step 5: 검증 성공 → 실행

사용자는 "구경만 함" 👀
```

---

## ⚠️ **현재 구현의 한계**

### **현재 방식의 문제**

| 문제 | 설명 | 해결책 |
|------|------|--------|
| **중앙화** | 게임 서버가 지갑 제어 | 다중 서명 또는 타임락 |
| **개인키 노출** | 환경변수에 저장 | 하드웨어 지갑 또는 Vault |
| **즉시 실행** | 사용자 확인 없음 | 확인 메커니즘 추가 |
| **차후 취소 불가** | 일단 보내지면 끝 | 에스크로(Escrow) 시스템 |

### **프로덕션 개선 방안**

```typescript
// 1. 다중 서명 (2-of-3)
//    - 게임 서버
//    - 사용자
//    - 관리자
// → 최소 2명이 서명해야 실행

// 2. 타임락
//    - 요청 후 24시간 뒤 실행
//    - 취소 가능 기간 제공

// 3. 한도 제한
//    - 하루 최대 인출액 설정
//    - 대액 인출 시 추가 확인
```

---

## 📋 **현재 코드 플로우 (initiate-withdrawal.ts)**

```typescript
export async function onRequestPost(context: any) {
  // Step 1-2: 입력 검증
  const { walletAddress, withdrawalAmount } = body;
  
  // Step 2: KV에서 크레딧 확인
  const userState = await env.CREDIT_KV.get(stateKey);
  if (userState.credit < withdrawalAmount) {
    return { error: '크레딧 부족' };
  }
  
  // Step 3-4: 게임 지갑 복원
  const keyPair = keyPairFromSecretKey(
    Buffer.from(env.GAME_WALLET_PRIVATE_KEY, 'hex')
  );
  const gameWallet = WalletContractV4.create({
    publicKey: keyPair.publicKey,
    workchain: 0
  });
  
  // Step 5: seqno 증가
  const seqno = await getAndIncrementSeqno(env);
  
  // Step 6: Jetton 지갑 조회
  const gameJettonWalletAddress = await getJettonWalletAddress(
    env.CSPIN_TOKEN_ADDRESS,
    gameWallet.address.toString()
  );
  
  // Step 7-8: Payload + Message 생성
  const jettonPayload = buildJettonTransferPayload(...);
  const transferMessage = internal({
    to: gameJettonWalletAddress,
    body: jettonPayload
  });
  
  // Step 9: 서명
  const transfer = gameWallet.createTransfer({
    seqno,
    secretKey: keyPair.secretKey,
    messages: [transferMessage]
  });
  
  // Step 10: 전송
  const boc = transfer.toBoc().toString('base64');
  const txHash = await sendBocViaTonAPI(boc);
  
  // Step 11: KV 업데이트
  userState.credit -= withdrawalAmount;
  await env.CREDIT_KV.put(stateKey, JSON.stringify(userState));
  
  return { success: true, txHash };
}
```

---

## 🎓 **결론**

### **핵심 3가지**

1. **개인키가 서버에 있음**
   - 게임 서버가 게임 지갑 제어
   - 사용자 승인 불필요

2. **트랜잭션을 서버가 생성 & 서명**
   - 게임 지갑의 개인키로 서명
   - 사용자는 최종 수신자

3. **자동으로 블록체인에 브로드캐스트**
   - TonAPI 사용
   - 즉시 처리 (UX 우수)

---

**다음 질문 있으신가요? 🚀**

