# 🔍 사용자 추측 검증 및 핵심 문제 분석

**작성일**: 2025-10-25 오전 3:40  
**상태**: 🔴 핵심 문제 발견!

---

## 📋 사용자의 4가지 추측 검증

### 추측 #1: "CSPIN 입금 코드 분석이 잘못되어서 코드 수정이 잘못됨" 

**검증 결과**: ✅ **정확합니다!**

```
우리의 실수:
├─ 입금 분석: userJettonWalletAddress 사용 ✓
├─ 수정 사항: 인출에도 userJettonWalletAddress 사용
└─ 문제: 입금과 인출의 메커니즘이 다르다! ❌

입금 (사용자가 보냄):
  TX 구조: [사용자 지갑] → [게임 Jetton 지갑]
  address: userJettonWalletAddress (사용자의 Jetton 지갑 발신)
  payload: Jetton 전송 페이로드

인출 (게임이 보냄):
  TX 구조: [게임 지갑] → [사용자 지갑]
  address: ??? (무엇이 와야 하나?)
  payload: ??? (무엇이 와야 하나?)
  
우리는 입금 코드를 직접 복사했으므로 구조가 다릅니다!
```

---

### 추측 #2: "클라우드플레어 Pages 환경에서 개인키를 환경변수에 넣고 게임지갑 -> 사용자로 CSPIN 토큰전송이 기술적으로 가능한가?"

**검증 결과**: ⚠️ **기술적으로는 가능하지만 문제가 있습니다!**

```
현재 상황:
├─ GAME_WALLET_PRIVATE_KEY: Cloudflare 환경변수에 저장 ✓
├─ RPC 엔드포인트: Ankr API (public) ✓
└─ 백엔드: Cloudflare Workers (serverless) ✓

기술적 가능성:
┌─ Workers에서 개인키 사용 가능? ✓ 가능
│  └─ Node.js 형 @ton/crypto 라이브러리 있음
│
├─ Jetton 전송 가능? ✓ 가능
│  └─ BOC 생성 + RPC 서명 + 전송 모두 가능
│
└─ 비용?
   └─ Cloudflare Workers Free: 100,000 요청/일
      충분함 ✓

그런데 중앙화 방식에서는:
├─ 사용자가 승인해야 함
├─ 사용자의 지갑 = Jetton 중간 지갑
├─ 사용자가 직접 서명
└─ 백엔드는 BOC만 생성하고 전달하는 역할 ❌❌❌

우리는 이 부분을 놓쳤습니다!
```

---

### 추측 #3: "개인키만 있으면 TON 블록체인 상에서 실제 사람이 승인 안해도 CSPIN 토큰을 전송할 수 있나?"

**검증 결과**: ✅ **정확합니다! 이것이 RPC 방식입니다!**

```
개인키의 의미:
├─ 개인키 = 그 지갑의 전자서명 권한
├─ 개인키로 서명 = 지갑 소유자가 직접 서명
└─ 백엔드에서 개인키 사용 = 백엔드가 지갑을 제어

즉:
백엔드가 게임 지갑의 개인키 보유
  ↓
게임 지갑 대신 서명 가능
  ↓
사용자 승인 없이 Jetton 전송 가능
  ↓
이것이 RPC 방식! ✅

그런데 중앙화 방식은 다릅니다:
├─ 사용자의 지갑 개인키는 절대 백엔드에 없음
├─ 사용자만 자신의 지갑을 서명할 수 있음
├─ 백엔드는 BOC만 생성 → 프론트로 전달
├─ 프론트: TON Connect → 사용자 서명
└─ 사용자가 승인해야만 전송 가능

우리는 "중앙화 방식 = 사용자 서명 필요"를 놓쳤습니다!
```

---

### 추측 #4: "Cloudflare Pages + Cloudflare Workers를 추가해서 Workers에서 인출 백엔드를 작동시키는 것은?"

**검증 결과**: ✅ **현재 이미 그렇게 하고 있습니다!**

```
현재 아키텍처:
├─ Cloudflare Pages: 프론트엔드 배포 ✓
├─ Cloudflare Workers: 백엔드 API
│  ├─ functions/api/initiate-withdrawal.ts ✓
│  ├─ functions/api/rpc-utils.ts ✓
│  └─ Wrangler로 배포됨 ✓
└─ Ankr RPC: TON 블록체인 연동 ✓

즉, 이미 Workers를 사용하고 있으므로:
├─ 추가할 필요 없음
├─ 이미 최적의 구조
└─ 문제는 다른 곳에 있음! 🔴
```

---

## 🔴 **핵심 문제 발견!**

### 백엔드 코드의 결정적 오류

**initiate-withdrawal.ts (라인 200)**:

```typescript
// ❌ 문제!
const boc = jettonPayload.toBoc().toString('base64');
```

### 입금 코드 vs 인출 코드

**입금** (Deposit.tsx):
```typescript
const transaction = {
  messages: [
    {
      address: userJettonWalletAddress,  // Jetton 지갑 주소
      amount: '200000000',               // 가스비
      payload: payload                    // Jetton 페이로드
    }
  ]
};
```

**인출 - 우리의 수정** (GameComplete.tsx):
```typescript
const tx = {
  messages: [{
    address: userFriendlyJettonAddress,  // Jetton 지갑 주소
    amount: '30000000',                  // 가스비
    payload: result.boc                  // ← 백엔드에서 받은 BOC
  }]
};
```

**여기서 백엔드가 보내는 BOC가 뭐냐?**

```
현재 (❌ 잘못됨):
const boc = jettonPayload.toBoc().toString('base64');
         ↑ 오직 페이로드만

입금에서 실제로 하는 것 (✅ 올바름):
const transaction = {
  messages: [{
    address: userJettonWalletAddress,
    amount: '200000000',
    payload: buildJettonTransferPayload(...)  // 직접 생성해서 전달
  }]
};
```

**차이점**:
```
입금: TON Connect에서 직접 Jetton 페이로드를 payload 필드에 넣음
인출: 백엔드에서 BOC를 생성 → 프론트에서 payload에 넣음

프론트에서는 이 BOC를 어떻게 해석할 것인가?
❌ 현재: "단순 바이트 데이터"로 해석
✅ 올바름: "Jetton 페이로드 + 메시지 구조"로 해석
```

---

## 🎯 실제 문제

### 중앙화 방식의 메커니즘

```
올바른 흐름:
1. 백엔드: 게임 지갑의 BOC 생성 (실제 트랜잭션 구조)
   ├─ seqno 포함
   ├─ 게임 지갑 → 사용자 Jetton 지갑
   ├─ 메시지: Jetton 페이로드
   └─ 서명: 필요 없음 (사용자가 서명)

2. 프론트: BOC를 TON Connect에 전달
   ├─ TON Connect가 BOC를 분석
   ├─ "이것은 Jetton 트랜잭션입니다" 감지
   ├─ 사용자에게 표시: "CSPIN을 보낼 것입니다"
   └─ 사용자가 승인/거부

3. 사용자 서명 후
   ├─ 서명된 BOC 반환
   ├─ 프론트: 네트워크에 제출
   └─ 완료!

현재 우리의 잘못된 흐름:
1. 백엔드: Jetton 페이로드만 BOC로 생성 ❌
2. 프론트: 이 BOC를 payload에 넣음 ❌
3. TON Connect: "이게 뭐지?" 혼동
4. 표시: "TON 전송" (잘못된 해석)
```

---

## ✅ 해결책

### 중앙화 방식의 올바른 구현

```
사용자가 서명해야 할 것:
┌────────────────────────────────────────────┐
│ 트랜잭션 (전체)                            │
├────────────────────────────────────────────┤
│ From: 사용자 지갑                          │
│ Messages: [                                │
│   {                                        │
│     To: 사용자 Jetton 중간 지갑            │
│     Amount: 0.03 TON (가스비)             │
│     Body: Jetton 페이로드                  │
│       (CSPIN 전송 명령)                    │
│   }                                        │
│ ]                                          │
│ Seqno: X                                   │
│ 서명: [사용자가 개인키로 서명] ✅          │
└────────────────────────────────────────────┘

즉:
- 백엔드: 메시지 구조만 생성
- 프론트: 사용자 지갑의 전체 트랜잭션으로 완성
- 사용자: 전체 트랜잭션에 서명
```

---

## 🤔 우리의 근본적 오류

### 입금 vs 인출의 구조 차이

**입금** (사용자가 CSPIN을 보냄):
```
사용자 지갑 (TON)
  ↓ (사용자가 서명)
  ├─ 메시지: Jetton 페이로드
  ├─ 목적지: 게임 Jetton 중간 지갑
  └─ 결과: 게임이 CSPIN 수령
  
프론트엔드 코드로 충분:
├─ 사용자 TON 지갑 직접 제어
├─ Jetton 페이로드 생성
└─ TON Connect 호출
```

**인출** (게임이 CSPIN을 보냄):
```
게임 지갑 (TON)
  ↓ 게임 지갑이 서명? 또는 사용자가 서명?
  
두 가지 방식 가능:
┌─ RPC 방식: 게임 지갑의 개인키로 백엔드가 서명
│  ├─ 백엔드: 전체 트랜잭션 생성 + 서명
│  ├─ 사용자: 승인 불필요
│  └─ 결과: 즉시 완료
│
└─ 중앙화 방식: 사용자가 대신 서명?
   ├─ 사용자가 뭘 서명해야 하나?
   ├─ 사용자 지갑이 아니라 게임 지갑인데?
   └─ 기술적으로 불가능! ❌
```

---

## 💡 깨달음

**우리가 착각한 것**:
```
"입금 코드처럼 하면 입출이 대칭일 것"
```

**현실**:
```
입금: 사용자 개인키 필요
     → 프론트에서 가능 (사용자의 지갑에 접근 가능)

인출: 게임 개인키 필요 (또는 사용자가 뭔가 대신 서명?)
     → 프론트에서 불가능 (게임 개인키는 백엔드에만 있음)
     → 백엔드에서만 가능 (RPC 방식)
```

---

## 🎯 결론

### 중앙화 방식은 원래 불가능했나?

**NO!** 하지만 다르게 구현해야 합니다:

```
중앙화 방식의 올바른 정의:
├─ "사용자가 서명" ❌ (잘못된 이해)
├─ "사용자가 승인" ✓ (올바른 이해)
└─ "실제로는 누가 서명?":
   ├─ TON Connect UI에서 "이 트랜잭션을 실행?"
   ├─ 사용자가 "Yes" 클릭
   ├─ 사용자 지갑이 실행
   ├─ 사용자 지갑이 자신의 개인키로 서명
   ├─ 그런데 이 지갑이 "게임 지갑을 대신 제어"할 수는 없음!
   └─ 따라서 중앙화 방식은 현재 구조에서 불가능 ❌

우리는 뭔가 이상한 걸 시도했습니다:
├─ 사용자 지갑: 게임 지갑을 대신 제어?
├─ 게임 지갑의 CSPIN: 사용자가 전송?
└─ 이건 기술적으로 불가능! ❌
```

---

## ✅ 올바른 방식

### 인출을 위한 2가지 방식

#### 방식 A: RPC (추천) ✅

```
게임 지갑의 개인키로 서명 (백엔드에서)
├─ 백엔드: 전체 BOC 생성 + 서명
├─ 프론트: 단순히 "완료" 표시
├─ 사용자 승인: 불필요
├─ 속도: 빠름 (1-2초)
└─ 현재 구현 가능 ✓
```

#### 방식 B: 사용자가 게임 지갑 제어 (거의 불가능)

```
이론적으로:
├─ 사용자가 TON Connect에서 "게임 지갑" 연결?
├─ 불가능! (사용자 지갑만 연결 가능)
└─ 기술적으로 달성 불가능 ❌
```

---

## 🚀 권장 방안

### 중앙화 방식은 제거하고 RPC 방식만 사용

```
이유:
1. 중앙화 방식의 원래 개념이 맞지 않음
2. 실제로 구현 불가능
3. RPC 방식이 기술적으로 올바름
4. 사용자 경험도 더 좋음 (승인 불필요)

하지만 문제:
└─ RPC CORS 오류 해결 필요
```

---

## 📊 최종 정리

| 추측 | 검증 | 결론 |
|------|------|------|
| **#1** | ✅ 정확 | 우리의 분석이 잘못됨 |
| **#2** | ⚠️ 기술적 가능 | 하지만 중앙화 방식 구조가 잘못됨 |
| **#3** | ✅ 정확 | RPC 방식의 개념 정확 |
| **#4** | ✅ 이미 적용 | 최적의 아키텍처 |

---

## 🎯 다음 조치

1. ✅ **RPC 방식에만 집중**
   - Ankr Origin 문제 해결
   - RPC 테스트

2. ❌ **중앙화 방식 제거 또는 재정의**
   - 현재 구조에서는 불가능
   - 다른 구조 필요 (복잡함)

3. ✅ **사용자 경험**
   - RPC: 빠르고 간단 (1-2초)
   - 중앙화: 복잡하고 느림 (15-30초)

---

**결론: 사용자의 모든 추측이 핵심을 건드렸습니다!** ✅

하지만 해결책은 **RPC 방식에만 집중하는 것**입니다! 🚀

