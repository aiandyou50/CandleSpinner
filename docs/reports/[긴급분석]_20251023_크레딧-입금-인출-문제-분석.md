# [긴급분석] 크레딧 입금/인출 문제점 및 해결 계획

**작성일**: 2025년 10월 23일  
**우선순위**: 🔴 Blocking (MVP 기능 마비)  
**상태**: 🔍 문제 분석 완료 → 🛠️ 수정 진행 중

---

## 1. 현재 문제점 (사용자 리포트)

### 문제 1: 입금 후 크레딧이 증가하지 않음
- **현상**: CSPIN 토큰 100개를 입금했는데도 크레딧이 1,000으로 유지됨
- **원인**: KV에 저장된 크레딧이 프론트엔드의 `useGameState`와 **동기화되지 않음**
- **영향**: 크레딧 영속성 검증 불가

### 문제 2: 인출 트랜잭션이 발생하지 않음
- **현상**: "1000 CSPIN 인출 요청 보냄" 메시지만 표시, 실제 트랜잭션 없음
- **원인**: `/api/initiate-withdrawal` API가 실제 Jetton 트랜잭션을 생성하지 않음
- **영향**: 사용자가 인출 후에도 게임 지갑에서 CSPIN이 나가지 않음

### 문제 3: 초기 크레딧 관리 부재
- **현상**: 모든 사용자가 기본 1,000 크레딧으로 시작
- **원인**: `useGameState(initialCredit = 1000)`에서 하드코딩됨
- **원인2**: KV에 저장된 실제 크레딧과 프론트엔드 상태가 별개
- **영향**: 새 사용자는 1,000 크레딧, 기존 사용자는 KV 값으로 충돌 발생

---

## 2. 근본 원인 분석

### 2.1 크레딧 영속성 문제 흐름

```
사용자 CSPIN 입금 시작
    ↓
[온체인] Jetton Transfer 발생
    ↓
[프론트엔드] TonConnect 서명 완료
    ↓
[백엔드] /api/deposit 호출 (txHash 기반)
    ├─→ KV: state:${walletAddress} 업데이트 ✅
    └─→ KV: balance:${walletAddress} 업데이트 ✅
    
[프론트엔드] onDepositSuccess 콜백 호출
    ├─→ Game.tsx 컴포넌트 리렌더링? ❓ (확인 필요)
    └─→ useGameState.updateCredit() 호출? ❓ (호출 없음)
    
[현상] 화면의 크레딧 = useGameState의 useState 값 (1,000)
      KV의 크레딧 = state:${walletAddress}.credit (1,100)
      👉 **두 값이 다름!**
```

**핵심 문제**: `/api/deposit` 성공 후 프론트엔드가 새 상태를 적용하지 않음

### 2.2 인출 실패 문제 흐름

```
사용자 인출 요청
    ↓
[프론트엔드] Deposit.tsx의 handleWithdraw() 함수? 
           (Game.tsx에는 handleWithdraw()가 있지만 API 호출 미구현)
    ↓
Game.tsx showToast("1000 CSPIN 인출 요청 보냈습니다")
    ↓
❌ 실제 API 호출 없음!
    ❌ KV 크레딧 차감 없음!
    ❌ Jetton 트랜잭션 생성 없음!
```

**핵심 문제**: 인출 버튼 클릭 시 **백엔드 API를 호출하지 않음**

---

## 3. 코드 레벨 문제점

### 3.1 Game.tsx - 인출 로직 부재

**라인 ~200**: showToast만 호출하고 API 호출 없음
```tsx
// ❌ 현재 코드
setMessage("1000 CSPIN 인출 요청을 보냈습니다.");
// API 호출 없음!
```

### 3.2 Deposit.tsx - 입금 후 상태 미동기화

**라인 ~630**: onDepositSuccess 콜백이 부모 컴포넌트만 호출
```tsx
// onDepositSuccess 존재하지만 Game.tsx에서 활용 안 함
if (onDepositSuccess) onDepositSuccess(amount);
```

**라인 ~630의 실제 동작**:
```tsx
// Deposit.tsx 내부
showToast("입금이 완료되었습니다!");
if (onDepositSuccess) onDepositSuccess(depositAmount);
```

문제: `onDepositSuccess` 콜백이 Game.tsx에 전달되지 않음!

### 3.3 useGameState - KV와 동기화 없음

**라인 25**: 모든 사용자에게 `initialCredit = 1000`
```tsx
export function useGameState(initialCredit = 1000) {  // ❌ 하드코딩!
  const [userCredit, setUserCredit] = useState(initialCredit);
```

문제: 
1. 초기값이 항상 1,000
2. KV에서 조회하지 않음
3. 입금 후 KV 업데이트를 반영하지 않음

### 3.4 /api/deposit - 백엔드는 정상

**`deposit.ts`**: KV 업데이트는 정상 작동
- `balance:${walletAddress}` ✅ 업데이트됨
- `state:${walletAddress}` ✅ 업데이트됨
- 응답: `{ newBalance, newCredit }` ✅

문제: **프론트엔드가 응답을 무시하고 KV를 다시 조회하지 않음**

### 3.5 /api/initiate-withdrawal - 2가지 구현 방식 혼재

**현재 상태**:
- Line 150+: `action='verify_only'` (검증만)
- Line 165+: `action='finalize'` (크레딧 차감만)
- Line 180+: Jetton 전송 로직 **불완전**

문제: 
1. 실제 Jetton 트랜잭션 생성 코드가 미흡
2. seqno 관리 부재
3. 프론트엔드에서 호출 미확인

---

## 4. 해결 계획 (우선순위 순)

### Phase 1: 입금 시 크레딧 즉시 반영 (목표: 2025-10-23 15:00)

**Step 1**: Deposit.tsx 수정
- onDepositSuccess 콜백 시 **KV에서 현재 크레딧 조회** (GET /api/get-credit)
- 또는 `/api/deposit` 응답의 `newCredit` 값 직접 사용

**Step 2**: Game.tsx 수정
- `onDepositSuccess` 콜백 처리 추가
- 조회한 크레딧으로 `updateCredit()` 호출
- 프론트엔드 상태 동기화

**Step 3**: useGameState 초기화 로직
- 컴포넌트 마운트 시 KV에서 크레딧 조회
- 없으면 기본값 1,000 설정

### Phase 2: 인출 기능 완전 구현 (목표: 2025-10-23 18:00)

**Step 1**: Game.tsx handleWithdraw 구현
- 인출 버튼 클릭 시 POST `/api/initiate-withdrawal` 호출
- 요청 바디: `{ walletAddress, withdrawalAmount }`

**Step 2**: /api/initiate-withdrawal 완성
- 원자적 seqno 관리: KV `game_wallet_seqno` 사용
  ```
  1. 읽기: game_wallet_seqno
  2. 증가: seqno + 1
  3. 쓰기: 트랜잭션 발생 확인 전에 KV 저장 금지 (실패 시 롤백)
  4. 실제 트랜잭션: Jetton Transfer 발송
  5. 완료: 크레딧 차감
  ```
- Jetton Transfer 메시지 정상 생성
- 트랜잭션 폴링 (30초, 2초 간격)
- 성공 시만 KV 크레딧 차감

**Step 3**: 에러 처리
- 충분한 잔액 확인
- 네트워크 오류 재시도
- Sentry 추적

---

## 5. 초기 크레딧 설정 논리

### 신규 사용자
1. KV 조회: `state:${walletAddress}` → 없음 (null)
2. 기본값 설정: `{ credit: 1000, ... }`
3. KV 저장: 첫 입금/스핀까지 저장 안 함 (필요 시에만)
4. UI 표시: 1,000 CSPIN

### 기존 사용자
1. KV 조회: `state:${walletAddress}` → `{ credit: 500, ... }`
2. UI 표시: 500 CSPIN (또는 0, 입금 유무에 따라)

### CSPIN 입금 시
1. 온체인: Jetton Transfer 발생
2. `/api/deposit` 호출 → KV 업데이트: `credit += depositAmount`
3. 프론트엔드: KV 조회 (GET /api/get-credit) → `updateCredit(newValue)`
4. UI 표시: 기존 크레딧 + 입금액

---

## 6. MCP 서버 검토

**질문**: MCP 서버가 필요한지?

**현재 구성**:
- 프론트엔드: React + Vite (로컬)
- 백엔드: Cloudflare Workers (Functions)
- 데이터: Cloudflare KV
- 배포: Cloudflare Pages

**MCP 서버의 역할** (만약 구축된다면):
- ⚠️ 명확하지 않음
- 가능성: 프롬프트 생성기? 문서 검색? 

**결론**: 
- ✅ 현재 아키텍처에는 **MCP 서버 불필요**
- 🗑️ **제거 권장** (유지보수 복잡도 증가)
- 📌 필요하면 나중에 추가

---

## 7. 다음 단계

### 즉시 실행 (이번 세션)
1. [ ] Deposit.tsx 수정: 입금 후 KV 크레딧 동기화
2. [ ] Game.tsx 수정: handleWithdraw 구현 + API 호출
3. [ ] useGameState 초기화 로직 개선
4. [ ] /api/initiate-withdrawal 완성

### 검증
- [ ] npm test (12/12 통과 확인)
- [ ] 수동 테스트
  - [ ] 입금 후 크레딧 증가 확인
  - [ ] 새로고침 후 크레딧 유지 확인
  - [ ] 인출 시 블록체인 트랜잭션 발생 확인
  - [ ] 인출 후 크레딧 차감 확인

### 배포
- [ ] git commit + push (Cloudflare Pages 자동 배포)

---

**상태**: 분석 완료, Phase 1 개선 시작 대기 ⏳

