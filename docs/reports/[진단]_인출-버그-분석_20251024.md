# 인출 기능 버그 진단 보고서

**작성일**: 2025-10-24  
**상태**: 🔴 실패 (2가지 오류 분석됨)

---

## 📋 발생한 오류

### 1️⃣ 중앙화 방식 인출 실패

**오류 메시지**:
```
API 응답 상태: 500
❌ 오류: TonAPI Jetton 지갑 조회 실패: 400
```

**근본 원인**:
- TonAPI의 `/v2/jettons/wallets` 엔드포인트 호출 실패
- 응답: HTTP 400 Bad Request
- 원인: 
  - API 키 없음 (또는 잘못됨)
  - 엔드포인트 형식 오류
  - 파라미터 형식 오류

**현재 코드 (문제)**:
```typescript
const url = 'https://tonapi.io/v2/jettons/wallets';
const params = new URLSearchParams({
  owner_account: normalizedOwnerAddress,
  jetton: normalizedMasterAddress
});
```

**문제점**:
- TonAPI는 API 인증이 필요한데 없음
- 또는 엔드포인트가 변경되었음
- 또는 파라미터 형식이 잘못됨

---

### 2️⃣ RPC 방식 인출 실패

**오류 메시지**:
```
API 응답 상태: 500
❌ 오류: RPC Error -32079: Origin not allowed
```

**근본 원인**:
- Ankr RPC 엔드포인트에서 **CORS 오류** 발생
- 이는 클라이언트 사이드에서 직접 RPC 호출 시도 시 발생
- **그런데 현재 코드는 백엔드(Cloudflare Workers)에서 호출 중임**

**분석**:
- Ankr RPC는 서버 사이드 호출만 허용
- 오류 코드 -32079는 "Origin not allowed" 
- 클라우드플레어 워커의 Origin이 Ankr에 등록되지 않음

---

## 🔍 기술 분석

### TonAPI 문제 분석

| 항목 | 현황 |
|------|------|
| 엔드포인트 | `https://tonapi.io/v2/jettons/wallets` |
| 메서드 | GET |
| 파라미터 | `owner_account`, `jetton` |
| 인증 | ❌ 없음 |
| 상태 | ❌ 400 Bad Request |

**해결 방안**:
1. TonAPI 문서 확인 → 올바른 엔드포인트 사용
2. API 키 추가 (Tonkeeper API가 아닌 경우)
3. 또는 다른 공급자 사용 (Tonana, Tonalytics 등)
4. 또는 **프론트엔드에서 미리 계산하여 주소 전달**

### RPC CORS 문제 분석

| 항목 | 현황 |
|------|------|
| RPC 제공자 | Ankr |
| Origin | Cloudflare Workers (인식 불가) |
| 상태 | ❌ Origin not allowed (-32079) |

**해결 방안**:
1. Ankr 대시보드에서 Origin 등록
2. 또는 다른 RPC 제공자 사용 (Getblock, Infura 등)
3. 또는 **프론트엔드에서 직접 RPC 호출** (하지만 보안 문제)

---

## 💡 권장 해결책

### 옵션 A: 간단한 임시 해결책 ✅ (추천)

**개념**:
- Jetton 지갑 주소를 **사용자로부터 받기** 또는 **프론트엔드에서 계산**
- 또는 **고정 주소 사용** (테스트용)

**장점**:
- 즉시 구현 가능
- 외부 API 의존성 제거
- 테스트 가능

**단점**:
- 프로덕션 환경에서는 부족

### 옵션 B: 올바른 API 통합

**개념**:
- TonAPI 올바른 엔드포인트 찾기
- API 키 설정
- Ankr Origin 등록

**장점**:
- 프로덕션 환경 지원

**단점**:
- 시간 소요
- 외부 의존성 증가

### 옵션 C: 다른 라이브러리 사용

**개념**:
- `tonweb` 또는 `ton.js` 라이브러리 사용
- 내장된 Jetton 지갑 계산 함수 활용

**장점**:
- 검증된 코드

**단점**:
- 라이브러리 추가
- 학습곡선

---

## 🛠️ 즉시 적용 가능한 해결책

### 1단계: 하드코딩된 주소 사용 (테스트)

```typescript
// 임시: 각 사용자별 jetton 지갑 주소를 환경변수로 관리
// 또는 사용자 요청에 포함시키기
const jettonWalletAddress = body.jettonWalletAddress || env.USER_JETTON_WALLET;
```

### 2단계: 프론트엔드에서 계산

```typescript
// 프론트엔드
const jettonWallet = await calculateJettonWalletAddress(
  CSPIN_TOKEN_ADDRESS, 
  userWalletAddress
);

// 백엔드 요청
fetch('/api/initiate-withdrawal', {
  body: JSON.stringify({
    walletAddress,
    withdrawalAmount,
    jettonWalletAddress: jettonWallet  // ← 추가
  })
});
```

### 3단계: RPC 호출 제거

```typescript
// Jetton 지갑 조회를 위해 RPC 호출 제거
// 대신 프론트엔드에서 미리 주소 계산하여 전달
```

---

## 📊 다음 조치

### 우선순위

1. **🔴 긴급**: 임시 해결책 적용 (하드코딩 또는 프론트엔드 계산)
2. **🟡 중요**: API 키 설정 또는 다른 RPC 제공자 찾기
3. **🟢 정상**: 프로덕션 환경 최적화

### 예상 해결 시간

- 옵션 A (임시): **5-10분**
- 옵션 B (API 통합): **30-60분**
- 옵션 C (라이브러리): **15-30분**

---

## 🎯 결론

**즉시 조치 필요**:
1. ✅ TonAPI 엔드포인트 확인 또는 변경
2. ✅ API 키 추가 (필요시)
3. ✅ 프론트엔드에서 Jetton 지갑 주소 계산하여 전달
4. ✅ RPC 호출 최적화

**성공 기준**:
- ✅ 중앙화 방식: 사용자가 서명 가능한 BOC 생성
- ✅ RPC 방식: txHash 반환
- ✅ 디버그 로그: 각 단계별 상세 로깅

---

**다음**: 임시 해결책 적용 → 프로덕션 최적화
