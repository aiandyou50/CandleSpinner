# 문제 분석 및 해결책

**작성일**: 2025-10-25  
**상태**: 🔴 긴급 수정 필요

---

## 문제 #1: 중앙화 방식 - TON 전송이 아니라 CSPIN 전송해야 함 🔴

### 현재 상황 (❌ 오류)
```
사용자가 게임에서 CSPIN 1000개 인출 요청
↓
백엔드가 BOC 생성
↓
TON Connect에 전달
↓
사용자 지갑에 보이는 것: 
   ❌ "0.03 TON을 자신에게 보낼 것입니다"
   (원래는: "1000 CSPIN을 받을 것입니다")
↓
사용자가 거부
```

### 원인 분석

**중앙화 방식의 동작 원리** (Jetton 표준 TEP-74):
```
게임 지갑의 CSPIN 중간 지갑
    ↓
    ├─ [1단계] 게임 지갑이 "CSPIN 전송" 메시지 생성
    │          (어디로? → 사용자의 CSPIN 중간 지갑)
    │
    ├─ [2단계] 그 메시지를 게임 지갑의 CSPIN 중간 지갑에 보냄
    │
    └─ [3단계] CSPIN 중간 지갑이 실행:
               "사용자의 CSPIN 중간 지갑으로 1000 CSPIN 전송"
```

**현재 코드 (initiate-withdrawal.ts, 라인 163)** ❌:
```typescript
// ❌ 문제!
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(gameWalletAddress),  // ❌ 게임 지갑?? (틀림!)
  Address.parse(walletAddress)
);

// 목적지: userJettonWalletAddress 설정이 잘못됨
const transferMessage = internal({
  to: Address.parse(userJettonWalletAddress),  // ✅ 맞음
  value: toNano('0.03'),
  body: jettonPayload  // ❌ 위에서 생성한 페이로드가 잘못됨
});
```

**실제 로직**:
```
1. Jetton 페이로드 생성:
   - 전송량: 1000 CSPIN ✅
   - 목적지: gameWalletAddress ❌ (틀림!)
   
   → 이 페이로드가 "게임 지갑 → 게임 지갑"이라는 의미가 됨
   → TON이 아닌 CSPIN을 보내려고 하는데 게임 지갑 자신에게?
   → 뭔가 이상해서 TON 트랜잭션으로 표시됨
```

### 올바른 로직

**Jetton 전송의 두 단계** (TEP-74):

```
[게임 지갑]
  ├─ 보유: CSPIN 중간 지갑 (예: UQBFPDdSlPgqPr...)
  └─ CSPIN 중간 지갑에 메시지 전송: 
     "다음 Jetton 페이로드를 실행해줘"
     
[CSPIN 중간 지갑]
  ├─ 받음: 게임 지갑으로부터의 메시지
  └─ 메시지 속 Jetton 페이로드:
     {
       operation: "transfer",
       amount: 1000 CSPIN,
       destination: 사용자의 CSPIN 중간 지갑,  ✅ 여기가 핵심!
       responseDestination: 게임 지갑
     }
     → CSPIN 중간 지갑이 이 페이로드를 실행
     → 사용자의 CSPIN 중간 지갑으로 1000 CSPIN 전송
```

### 수정방법

**buildJettonTransferPayload()** 함수의 파라미터:
```typescript
function buildJettonTransferPayload(
  amount: bigint,           // 1000 CSPIN
  destination: Address,     // ← 여기에 뭘 넣어야 하나?
  responseTo: Address       // ← 여기에?
)
```

**현재 코드** (라인 163):
```typescript
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(gameWalletAddress),     // ❌ 게임 지갑 (틀림!)
  Address.parse(walletAddress)
);
```

**올바른 수정**:
```typescript
// ✅ 올바른 로직
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(walletAddress),         // ✅ CSPIN을 받을 사용자
  Address.parse(gameWalletAddress)      // ✅ 반환값을 받을 게임 지갑
);
```

**왜?**
- `destination`: CSPIN을 최종적으로 받을 **사용자의 주소**
- `responseTo`: 트랜잭션 완료 후 응답을 받을 **게임 지갑**

### 수정할 파일

**`functions/api/initiate-withdrawal.ts`** (라인 163 근처)

```typescript
// ===== 중앙화 방식 (라인 150-175) =====

// 현재 (❌):
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(gameWalletAddress),     // ← 잘못됨
  Address.parse(walletAddress)
);

// 수정 후 (✅):
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(walletAddress),         // ← 사용자 주소
  Address.parse(gameWalletAddress)      // ← 게임 지갑
);

// ===== RPC 방식 (라인 101-105) =====

// 현재 (✅ 맞음):
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(walletAddress),         // ✅ 올바름
  gameWallet.address                    // ✅ 올바름
);

// 그대로 유지
```

---

## 문제 #2: RPC CORS 오류 - "Origin not allowed" 설명 📚

### "Origin"이란 무엇인가?

**웹 보안의 핵심 개념**:

```
웹사이트 A (https://aiandyou.me)
  ├─ 브라우저에서 실행
  ├─ 요청 헤더에 자동으로 포함:
  │  Origin: https://aiandyou.me
  │
  └─ 외부 API (RPC)에 요청
     ├─ RPC 서버가 "Origin" 헤더 확인
     ├─ 만약 등록되지 않은 Origin이면?
     │  → "CORS (Cross-Origin Resource Sharing) 오류"
     │  → 즉, "Origin not allowed"
     └─ 보안을 위해 차단
```

### 왜 Origin 체크를 할까?

**CSRF (Cross-Site Request Forgery) 공격 방지**:

```
공격 시나리오 (Origin 체크 없을 때):
1. 해커가 악의적인 웹사이트 운영
2. 사용자가 해커 사이트 방문
3. 해커 사이트의 JavaScript가 실행:
   - 사용자의 은행 API에 요청
   - 사용자 몰래 송금 명령
   - 가능? 불가능! (Origin 체크 때문)

Origin 체크로 보호:
- 은행 API 서버가 Origin 확인
- Origin이 등록된 도메인 아니면 차단
- 따라서 악의적 요청 차단
```

### 현재 상황

**현재 설정**:
```
Ankr RPC 대시보드:
  └─ TON 프로젝트의 허용 Origin 목록:
     ├─ https://aiandyou.me/ ✅ (등록됨)
     └─ ???  (다른 도메인?)
```

**요청 흐름**:
```
프론트엔드 (https://aiandyou.me)
  ├─ JavaScript에서: fetch("https://rpc.ankr.com/...")
  ├─ 자동 추가: Origin: https://aiandyou.me
  ├─ 하지만 지금은 클라우드플레어 워커를 거쳐서 요청?
  │  → 그러면 Origin이 달라질 수 있음!
  │  → Ankr에서 인식하는 Origin ≠ 실제 Origin
  └─ 결과: "Origin not allowed" 오류 (-32079)
```

### 해결책

**3가지 방안** (우선순위 순):

#### 방안 A: Ankr 대시보드 재확인 (80% 확률)

```
1. https://www.ankr.com/dashboard 접속
2. TON 프로젝트 선택
3. "Endpoints" 탭 클릭
4. "Allowed Origins" 섹션 확인:
   
   확인 항목:
   ✓ https://aiandyou.me/ 등록?
   ✓ 클라우드플레어 워커 Origin? (?)
   ✓ 캐시 갱신됨? (5분 이상)
   
5. 필요시 Origin 추가:
   - https://aiandyou.me
   - 클라우드플레어 도메인 (확인 필요)
   
6. 저장 후 5-10분 대기

테스트:
- 브라우저 개발자 도구 → Network
- RPC 요청 헤더 확인:
  Origin: https://aiandyou.me
  (이 Origin이 Ankr에 등록되어 있는가?)
```

#### 방안 B: 클라우드플레어 워커의 실제 Origin 파악

```
클라우드플레어 워커는 Edge에서 실행:
- 요청 Origin이 https://aiandyou.me 아닐 수 있음
- 워커 자체의 도메인이 다를 수 있음

확인 방법:
1. 백엔드 로그에 Origin 헤더 기록:
   console.log('[RPC] 요청 Origin:', context.request.headers.get('Origin'));
   
2. 로그 확인:
   - 실제 Origin이 뭔지 보기
   - Ankr에 이 Origin 등록하기
```

#### 방안 C: 백엔드 프록시 구현 (최후의 수단)

```
프론트 → 백엔드 프록시 → Ankr RPC

장점:
- 백엔드에서 RPC 호출 (Origin 상관없음)
- 프론트는 백엔드에만 요청 (같은 도메인)

단점:
- 추가 지연 발생
- 백엔드 서버 부하 증가
```

---

## 🚀 지금 바로 할 것

### 1️⃣ 중앙화 방식 코드 수정 (5분)

**파일**: `functions/api/initiate-withdrawal.ts`

**수정 위치**: 라인 163 (중앙화 방식)

```typescript
// 현재 (❌):
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(gameWalletAddress),
  Address.parse(walletAddress)
);

// 수정 (✅):
const jettonPayload = buildJettonTransferPayload(
  toNano(withdrawalAmount.toString()),
  Address.parse(walletAddress),           // ← 순서 바꿈!
  Address.parse(gameWalletAddress)
);
```

### 2️⃣ 코드 수정 후 테스트

```
같은 절차로 재테스트:
1. 중앙화 방식 선택
2. Jetton 주소 입력
3. 10 CSPIN 인출 요청
4. TON Connect 확인:
   ✅ "1000 CSPIN을 받을 것입니다" (변경됨)
   (이전: 0.03 TON을 자신에게...)
5. 서명 및 완료
```

### 3️⃣ RPC Origin 문제 진단

**2가지 접근**:

```
A. Ankr 대시보드 확인 (즉시):
   1. https://www.ankr.com/dashboard
   2. TON 프로젝트 → Endpoints → Allowed Origins
   3. 스크린샷 또는 화면캡처
   4. 등록된 Origin 목록 기록

B. 백엔드 로그 추가 (대체):
   - RPC 호출할 때 Origin 헤더 기록
   - 실제 Origin 값 파악
   - Ankr에 이 Origin 등록
```

---

## 📋 체크리스트

```
중앙화 방식 수정:
[ ] initiate-withdrawal.ts 라인 163 수정
[ ] jettonPayload 목적지 walletAddress로 변경
[ ] 게임 실행
[ ] 중앙화 방식 재테스트
[ ] TON Connect 팝업 확인 (CSPIN 표시?)
[ ] 서명 및 완료

RPC Origin 문제:
[ ] Ankr 대시보드 접속
[ ] TON 프로젝트 → Endpoints 확인
[ ] Allowed Origins 목록 확인
[ ] https://aiandyou.me/ 등록 확인
[ ] 필요시 추가 Origin 등록
[ ] 5분 대기 (캐시 갱신)
[ ] RPC 방식 재테스트
```

---

## 예상 결과

### 중앙화 방식 (수정 후) ✅

```
1. Jetton 주소 입력
2. 10 CSPIN 인출
3. TON Connect 팝업:
   ✅ "1000 CSPIN을 위한 스마트 계약 호출"
      또는
   ✅ "CSPIN 토큰 전송"
4. 서명 → 완료 🎉
```

### RPC 방식 (Origin 해결 후) ✅

```
1. 같은 절차
2. 디버그 로그:
   [RPC] ✅ seqno 조회 완료
   [RPC] ✅ BOC 생성 완료
   [RPC] ✅ BOC 전송 성공: 0x...
3. 완료 🎉
```

---

## 📞 다음 보고

테스트 후 다음을 보고해주세요:

```
1. 중앙화 방식:
   [ ] TON Connect 팝업에 뭐라고 표시?
   [ ] 서명 가능?
   [ ] 완료됨?
   
2. RPC Origin:
   [ ] Ankr 대시보드 스크린샷
   [ ] 등록된 Origin 목록: ___________
   
3. RPC 재테스트:
   [ ] 오류 메시지: ___________
   [ ] 디버그 로그: (붙여넣기)
```

---

**핵심 요약**:
- ✅ 중앙화: `destination` 파라미터 순서 수정 필요
- 🟡 RPC: Ankr Origin 설정 확인 필요
- 📚 Origin: 웹 보안을 위한 CORS 메커니즘

