# 🔑 64자 vs 128자 개인키 상세분석

**작성일:** 2025-10-24  
**목적:** TON 블록체인의 개인키 형식 이해 및 CandleSpinner의 오류 원인 파악

---

## 1️⃣ **기본 개념: 바이트(byte) vs 16진수(hex)**

### 📏 단위 변환 기본

```
1 바이트 = 8 비트
1 바이트 = 16진수 2자리

예시:
- 1 바이트: 0xFF (16진수 2자리)
- 4 바이트: 0xDEADBEEF (16진수 8자리)
- 32 바이트: 64자리 16진수
- 64 바이트: 128자리 16진수
```

### 🔢 CandleSpinner의 경우

```javascript
// wallet-tools/mnemonic-to-key.mjs

const keyPair = await mnemonicToPrivateKey(mnemonic);

// ❌ 이전 (잘못된 방법)
const privateKeyHex = keyPair.secretKey.slice(0, 32).toString('hex');
// → 32바이트만 추출 = 64자리 16진수

// ✅ 수정됨 (올바른 방법)
const privateKeyHex = keyPair.secretKey.toString('hex');
// → 전체 64바이트 = 128자리 16진수
```

---

## 2️⃣ **ED25519 암호화 표준**

### 🔐 ED25519가 뭔가요?

**ED25519**는 **타원곡선 디지털 서명 알고리즘 (Elliptic Curve Digital Signature Algorithm)**입니다.

| 항목 | 값 |
|------|-----|
| **표준** | EdDSA (Edwards-curve Digital Signature Algorithm) |
| **곡선** | Curve25519 (montgom 형태) |
| **기원** | 2011년 개발, 보안과 성능으로 주목받음 |
| **사용처** | Signal, Tor, WireGuard, **TON 블록체인** |

### 📊 ED25519의 구성 요소

```
ED25519 키 쌍:

┌─────────────────────────────────────────┐
│       ED25519 Secret Key (64 바이트)    │
├─────────────────────────────────────────┤
│                                         │
│  ┌──────────────────┐  ┌──────────────┐ │
│  │ Seed (32바이트)  │  │ Prefix (32바 │ │
│  │                  │  │  이트)       │ │
│  └──────────────────┘  └──────────────┘ │
│                                         │
└─────────────────────────────────────────┘
         ↓ (파생)
┌─────────────────────────────────────────┐
│      ED25519 Public Key (32 바이트)     │
│   (16진수 64자리)                       │
└─────────────────────────────────────────┘
```

### 🔑 Secret Key의 구조

```typescript
// @ton/crypto의 keyPairFromSecretKey 함수 내부 동작

// Input: 64바이트 secret key
const secretKeyBuffer = Buffer.from(hexString, 'hex'); // 64 바이트

// 내부 처리:
const seed = secretKeyBuffer.slice(0, 32);      // 첫 32바이트 = 시드
const prefix = secretKeyBuffer.slice(32, 64);   // 나머지 32바이트 = 프리픽스

// 공개키 생성:
// ED25519 알고리즘이 seed + prefix를 사용하여 공개키 계산
```

---

## 3️⃣ **CandleSpinner에서 발생한 오류**

### 🚨 오류: "bad secret key size"

```
Error: bad secret key size
Location: keyPairFromSecretKey(Buffer.from(gameWalletPrivateKey, 'hex'))
```

### 왜 발생했나?

```javascript
// 이전 코드 (wallet-tools/mnemonic-to-key.mjs)
const privateKeyHex = keyPair.secretKey.slice(0, 32).toString('hex');
// → 32바이트만 추출
// → 16진수로 표현: 64자리

// @ton/crypto의 keyPairFromSecretKey 호출:
const keyPair = keyPairFromSecretKey(Buffer.from(privateKeyHex, 'hex'));
//                                              ↑
//                                        64바이트로 변환 시도
//                                        하지만 실제로는 32바이트만 있음!

// 결과: ❌ "bad secret key size" 오류!
```

### 📊 문제 비교

| 단계 | 64자 (32바이트) | 128자 (64바이트) | 결과 |
|------|-----------------|------------------|------|
| 니모닉 → keyPair | ✅ 생성됨 | ✅ 생성됨 | 두 경우 모두 가능 |
| secretKey 추출 | ❌ slice(0,32) | ✅ 전체 사용 | 크기 차이 발생 |
| keyPairFromSecretKey | ❌ **실패** | ✅ 성공 | **여기서 오류!** |
| 지갑 주소 생성 | ❌ 불가능 | ✅ 가능 | **이게 핵심** |

---

## 4️⃣ **왜 @ton/crypto는 64바이트를 요구하나?**

### 🎯 ED25519 표준

ED25519의 **표준 secret key 크기는 64바이트**입니다. 이는:

```
1. Seed (32바이트)
   - 원본 무작위 수
   - 니모닉으로부터 유도됨

2. Prefix (32바이트)
   - Ed25519 알고리즘의 일부
   - 서명 과정에서 필수
   - seed로부터 파생됨
```

### 🔍 @ton/crypto의 구현

```typescript
// @ton/crypto 내부 코드 (개념)

export function keyPairFromSecretKey(secretKey: Buffer): KeyPair {
  if (secretKey.length !== 64) {
    throw new Error('bad secret key size');
    // ↑ 정확히 64바이트만 허용!
  }

  const seed = secretKey.slice(0, 32);
  const prefix = secretKey.slice(32, 64);
  
  // ED25519 알고리즘으로 공개키 생성
  const publicKey = derivePublicKeyFromSeed(seed, prefix);
  
  return {
    secretKey,
    publicKey
  };
}
```

---

## 5️⃣ **니모닉 → 개인키 생성 과정**

### 📋 완전한 흐름

```
┌────────────────────────────────────────────────────────────┐
│  니모닉 (24개 영단어)                                       │
│  "tornado run casual carbon laptop..."                      │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ↓
┌────────────────────────────────────────────────────────────┐
│  @ton/crypto의 mnemonicToPrivateKey() 함수                 │
│  - BIP39 표준 적용                                          │
│  - PBKDF2로 키 유도                                         │
└────────────────────┬───────────────────────────────────────┘
                     │
                     ↓
┌────────────────────────────────────────────────────────────┐
│  keyPair 객체 반환                                          │
│  ├─ secretKey: Buffer (64바이트!)                          │
│  └─ publicKey: Buffer (32바이트)                           │
└────────────────────┬───────────────────────────────────────┘
                     │
    ┌────────────────┴──────────────────┐
    │                                   │
    ↓                                   ↓
❌ 잘못된 방법              ✅ 올바른 방법
slice(0, 32)               전체 사용
32바이트                   64바이트
64자 hex                   128자 hex
    │                      │
    ↓                      ↓
keyPairFromSecretKey    keyPairFromSecretKey
    ❌ 오류!                ✅ 성공!
```

---

## 6️⃣ **실제 코드 비교**

### ❌ 이전 (오류 발생)

```typescript
// wallet-tools/mnemonic-to-key.mjs - 이전 코드
async function mnemonicToWallet(mnemonicInput) {
  const mnemonic = mnemonicInput.trim().split(/\s+/);
  
  const keyPair = await mnemonicToPrivateKey(mnemonic);
  // keyPair.secretKey = Buffer (64바이트)
  
  // ❌ 문제: 32바이트만 추출!
  const privateKeyHex = keyPair.secretKey.slice(0, 32).toString('hex');
  // privateKeyHex = "4e6568d1990bff34..." (64자)
  
  // 이 값을 initiate-withdrawal.ts에서 사용:
  const keyPair2 = keyPairFromSecretKey(Buffer.from(privateKeyHex, 'hex'));
  // ❌ 오류! privateKeyHex는 32바이트인데 64바이트 필요!
}
```

### ✅ 현재 (수정됨)

```typescript
// wallet-tools/mnemonic-to-key.mjs - 현재 코드
async function mnemonicToWallet(mnemonicInput) {
  const mnemonic = mnemonicInput.trim().split(/\s+/);
  
  const keyPair = await mnemonicToPrivateKey(mnemonic);
  // keyPair.secretKey = Buffer (64바이트)
  
  // ✅ 전체 64바이트 사용!
  const privateKeyHex = keyPair.secretKey.toString('hex');
  // privateKeyHex = "4e6568d1990bff34...ef7978fc" (128자)
  
  // 이 값을 initiate-withdrawal.ts에서 사용:
  const keyPair2 = keyPairFromSecretKey(Buffer.from(privateKeyHex, 'hex'));
  // ✅ 성공! 정확히 64바이트 전달됨!
  
  const gameWallet = WalletContractV5R1.create({
    publicKey: keyPair2.publicKey,
    workchain: 0
  });
  // ✅ 지갑 주소 생성 가능!
}
```

---

## 7️⃣ **16진수 자릿수와 바이트의 관계**

### 🔢 변환 공식

```
바이트 크기 = 16진수 자릿수 / 2

예시:
- 1 바이트    = 2 자리   (0xFF)
- 2 바이트    = 4 자리   (0xFFFF)
- 16 바이트   = 32 자리  (128비트 = AES 암호화 키)
- 32 바이트   = 64 자리  (ED25519 공개키)
- 64 바이트   = 128 자리 (ED25519 개인키) ← TON에서 필요
```

### 📊 CandleSpinner의 경우

```
❌ 64자 16진수
  = 32바이트
  = ED25519 Seed만
  = 불완전 (Prefix 없음)
  = keyPairFromSecretKey() 실패

✅ 128자 16진수
  = 64바이트
  = ED25519 Secret Key (Seed + Prefix)
  = 완전 (표준 형식)
  = keyPairFromSecretKey() 성공
```

---

## 8️⃣ **다른 블록체인과의 비교**

### 🔐 개인키 크기 비교

| 블록체인 | 알고리즘 | Secret Key 크기 | 16진수 자릿수 | 비고 |
|---------|---------|-----------------|--------------|------|
| **Bitcoin** | ECDSA (secp256k1) | 32바이트 | 64자 | |
| **Ethereum** | ECDSA (secp256k1) | 32바이트 | 64자 | |
| **TON** | ED25519 | **64바이트** | **128자** | ← 다름! |
| **Solana** | ED25519 | **64바이트** | **128자** | ← 같음! |

### 🎯 왜 TON/Solana는 다른가?

```
Bitcoin/Ethereum: ECDSA (Elliptic Curve Digital Signature Algorithm)
- 공개키 유도 과정이 간단
- Secret key = seed (32바이트)만으로 충분

TON/Solana: ED25519 (Edwards-curve Digital Signature Algorithm)
- 공개키 유도 과정에 추가 계산 필요
- Secret key = seed (32바이트) + prefix (32바이트) 필요
```

---

## 9️⃣ **CandleSpinner의 수정 히스토리**

### 📜 타임라인

```
2025-10-24 초기 상태:
┌─────────────────────────────────────────┐
│ wallet-tools/mnemonic-to-key.mjs        │
│ → slice(0, 32) 사용                     │
│ → 64자 개인키 생성                      │
│                                         │
│ functions/api/initiate-withdrawal.ts    │
│ → keyPairFromSecretKey(64자)            │
│ → ❌ "bad secret key size" 오류!        │
└─────────────────────────────────────────┘

2025-10-24 디버그 API 생성:
┌─────────────────────────────────────────┐
│ debug-withdrawal.ts                     │
│ → length === 128 검증                   │
│ → 원인 파악: 128자 필요!                │
└─────────────────────────────────────────┘

2025-10-24 최종 수정 (커밋 fa716fa):
┌─────────────────────────────────────────┐
│ wallet-tools/mnemonic-to-key.mjs        │
│ → 전체 secretKey 사용                   │
│ → 128자 개인키 생성 ✅                  │
│                                         │
│ functions/api/initiate-withdrawal.ts    │
│ → keyPairFromSecretKey(128자)           │
│ → ✅ 성공!                              │
└─────────────────────────────────────────┘
```

---

## 🔟 **학습 정리: 핵심 3가지**

### 1️⃣ 바이트 vs 16진수
```
1 바이트 = 2 자리 16진수
64 바이트 = 128 자리 16진수
```

### 2️⃣ ED25519 표준
```
Secret Key = Seed (32바이트) + Prefix (32바이트) = 64바이트
@ton/crypto의 keyPairFromSecretKey()는 정확히 64바이트 필요
```

### 3️⃣ CandleSpinner의 오류
```
❌ slice(0, 32) → 32바이트 추출 → 64자 hex
✅ 전체 사용 → 64바이트 사용 → 128자 hex

64자를 128자로 변경한 이유: ED25519 표준 준수
```

---

## 📚 추가 학습 자료

### 🔗 참고 링크
- [ED25519 Wikipedia](https://en.wikipedia.org/wiki/EdDSA#Ed25519)
- [@ton/crypto GitHub](https://github.com/ton-org/ton/tree/master/crypto)
- [BIP39 니모닉 표준](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)

### 🧪 직접 테스트해보기

```bash
# 니모닉으로부터 128자 개인키 생성
node wallet-tools/mnemonic-to-key.mjs "your-24-word-mnemonic"

# 출력:
# Private Key (ED25519 - Full 64 bytes):
# 4e6568d1990bff34c3fc1e9243b8073262250bfab28d16a4d8c7ffd84479742d3a59677f67586df6a530023e054bfcd99e4cb2f7f134828d45905ba1ef7978fc
#
# → 이 128자 값이 initiate-withdrawal.ts에서 사용됨
```

---

## ✅ 결론

| 항목 | 64자 | 128자 |
|------|------|-------|
| **바이트 크기** | 32바이트 | 64바이트 |
| **ED25519 표준** | ❌ 불완전 | ✅ 완전 |
| **@ton/crypto 호환** | ❌ 오류 | ✅ 정상 |
| **CandleSpinner 사용** | ❌ 불가 | ✅ 필수 |
| **이유** | Seed만 포함 | Seed + Prefix |

**128자 개인키를 사용해야 하는 이유: ED25519 알고리즘이 64바이트 Secret Key를 요구하기 때문입니다!** 🔐
