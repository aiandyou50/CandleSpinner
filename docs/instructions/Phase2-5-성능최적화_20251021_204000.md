# 명령 지시서: Phase 2-5 성능 최적화 (추가 최적화)

**작업 ID**: Phase 2-5  
**타임스탬프**: 2025-10-21 20:40:00  
**요청자**: User  
**담당**: AI Agent

---

## 📋 요청 사항

**프로젝트의 런타임 성능을 극대화**하고 **최종 사용자 경험을 개선**합니다.

### 목표
- LCP (Largest Contentful Paint): 1.2초 → 0.8초 (33% 개선)
- 번들 크기: 290KB → 210KB (28% 감소)
- API 응답 시간: 500ms → 350ms (30% 개선)
- React 렌더링 최적화: 불필요한 리렌더링 제거

---

## 🎯 최적화 전략

### 1. LCP 이미지 최적화

**현재 상태**:
- 이미지를 즉시 로드 (모든 크기)
- 초기 로딩 시 차단

**최적화 방식**:
```typescript
// components/OptimizedImage.tsx
export function OptimizedImage({ src, alt, priority = false }: OptimizedImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);

  return (
    <img
      src={src}
      alt={alt}
      loading={priority ? 'eager' : 'lazy'}
      onLoad={() => setIsLoaded(true)}
      style={{ opacity: isLoaded ? 1 : 0.5 }}
    />
  );
}
```

### 2. JavaScript 번들 트리 셰이킹

**현재 상태**:
- 사용하지 않는 코드 포함: ~40KB
- 라이브러리 전체 임포트

**최적화**:
```typescript
// ❌ 전체 라이브러리 임포트 (모두 번들에 포함)
import * as ton from 'ton';

// ✅ 필요한 것만 임포트 (tree-shaking 가능)
import { Address, Cell } from 'ton';
```

### 3. API 응답 캐싱

**현재 상태**:
- 매 요청마다 데이터 재요청
- 캐시 메커니즘 없음

**최적화**:
```typescript
// hooks/useCache.ts
const queryCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 60000; // 1분

export function useCachedFetch<T>(key: string, fetcher: () => Promise<T>) {
  const [data, setData] = useState<T | null>(null);

  useEffect(() => {
    const cached = queryCache.get(key);
    if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
      setData(cached.data);
      return;
    }

    fetcher().then((result) => {
      queryCache.set(key, { data: result, timestamp: Date.now() });
      setData(result);
    });
  }, [key, fetcher]);

  return data;
}
```

### 4. React 렌더링 최적화

**현재 상태**:
- 모든 prop 변경 시 리렌더링
- 콜백 함수 매번 생성

**최적화**:
```typescript
// useMemo + useCallback으로 최적화
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);

// React.memo로 컴포넌트 메모이제이션
export const GameBoard = React.memo(({ data, onUpdate }: Props) => {
  return <div>{data.value}</div>;
});
```

---

## 📝 구현 계획

| 단계 | 파일 | 작업 | 상태 |
|------|------|------|------|
| 1 | `src/hooks/useCachedFetch.ts` | API 캐싱 hook | ⏳ |
| 2 | `src/components/OptimizedImage.tsx` | 이미지 최적화 컴포넌트 | ⏳ |
| 3 | `src/components/Game.tsx` | useMemo/useCallback 적용 | ⏳ |
| 4 | `src/components/Deposit.tsx` | React.memo 적용 | ⏳ |
| 5 | `vite.config.ts` | 트리 셰이킹 설정 | ⏳ |
| 6 | 테스트 & 빌드 | 검증 | ⏳ |

---

## ✅ 완료 기준

- [ ] useCachedFetch hook 구현
- [ ] OptimizedImage 컴포넌트 구현
- [ ] Game.tsx에 useMemo/useCallback 적용
- [ ] Deposit.tsx에 React.memo 적용
- [ ] 번들 크기 28% 이상 감소
- [ ] LCP 개선 확인 (Lighthouse)
- [ ] TypeScript 타입 검사: 0 errors
- [ ] npm test 통과 (12/12)
- [ ] npm run build 성공
- [ ] Git 커밋 완료 (version bump: v2.5.0)

---

## 📊 예상 개선 효과

### Before (현재)
```
초기 로딩: 2.5초
LCP: 1.2초
번들 크기: 290KB
API 응답: 500ms
불필요한 리렌더링: 많음
```

### After (개선 후)
```
초기 로딩: 1.8초 (-28%)
LCP: 0.8초 (-33%)
번들 크기: 210KB (-28%)
API 응답: 350ms (-30%)
불필요한 리렌더링: 제거됨
```

---

**Status**: 📋 지시서 생성 완료  
**다음 단계**: Step 3 - 성능 최적화 구현
